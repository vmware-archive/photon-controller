#!/bin/bash
tools=$(readlink -nf $(dirname $0))
source $tools/common.sh

function usage() {
  echo "Usage: $0 HOST_ADDRESS USERNAME PASSWORD VIB_PATH" 1>&2
  echo
  echo "Supplied args:"
  echo $*
  exit 1
}

host_address=""
username=""
password=""
vib_path=""
create_cert=""
lightwave_domain=""
lightwave_address=""
lightwave_password=""

if [ "$#" -lt 4 ]
then
  usage $*
fi

host_address=$1
shift
username=$1
shift
password=$1
shift
vib_path=$1
shift
create_cert=$1
shift
lightwave_domain=$1
shift
lightwave_address=$1
shift
lightwave_password=$1
shift



while getopts d:l:n:h flag
do
  case $flag in
    ?)
      usage $*
      ;;
  esac
done

function install_vib() {
  sshpass -p "$password" ssh -o StrictHostKeyChecking=no ${username}@${host_address} esxcli software vib install -f -v $vib_path
  if [[ $? -ne 0 ]]
  then
    echo "retrying installing vib"
	  sshpass -p "$password" ssh -o StrictHostKeyChecking=no ${username}@${host_address} esxcli software vib install -f -v $vib_path

	  if [[ $? -ne 0 ]]
	  then
	    exit 1
	  fi
	fi
}

# Add java home and other required binaries to path. We need this here even though we are doing this during container
# build because systemd service does not seem to honor the environment variables set at container build time.
export JAVA_HOME="/usr/java/default"
export PATH=$PATH:$JAVA_HOME/bin:/opt/esxcli:/opt/vmware/bin:/opt/likewise/bin

if [ "$create_cert" == "true" ]
then
  cert_dir="./host_cert_${host_address}"
else
  cert_dir="./host_cert_no_auth"
fi

host_cert_dir="/etc/vmware/ssl"
priv_key_name="host.privkey"
pub_key_name="host.pubkey"
crt_name="host.crt"
pem_name="host.pem"
priv_key_path="${cert_dir}/${priv_key_name}"
pub_key_path="${cert_dir}/${pub_key_name}"
host_crt_path="${cert_dir}/${crt_name}"
host_pem_path="${cert_dir}/${pem_name}"
esxi_priv_key_path="${host_cert_dir}/${priv_key_name}"
esxi_pub_key_path="${host_cert_dir}/${pub_key_name}"
esxi_host_crt_path="${host_cert_dir}/${crt_name}"
esxi_host_pem_path="${host_cert_dir}/${pem_name}"

function create_and_copy_certificate() {

  cert_alias=`keytool --list --keystore /keystore.jks -storepass ${lightwave_password} -alias MACHINE_CERT_${host_address}`
  if [[ "$cert_alias" == *"does not exist"* ]]; then

    rm -rf ${cert_dir}
    mkdir -p ${cert_dir}

    echo "Deleting cert for ${host_address}"
    # need to delete cert placed here during initial non-auth rollout
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} rm -f "${host_cert_dir}/host_cert_no_auth"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} rm -f "${esxi_host_crt_path}"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} rm -f "${esxi_host_pem_path}"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} rm -f "${esxi_pub_key_path}"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} rm -f "${esxi_priv_key_path}"
    #copying the config file to local directory which is going to be used in the cerficate generation.
    config_file_path="${cert_dir}/certool.cfg"
    cp /opt/vmware/share/config/certool.cfg "${config_file_path}"

    # Fill in the ip address for generating a host certificate
    sed -i s/IPAddress.*/"IPAddress = ${host_address}"/ "${config_file_path}"

    # Generate keys if they don't exist
    if [ ! -f "${priv_key_path}" ] || [ ! -f "${pub_key_path}" ]; then
      echo "Creating keys for ${host_address}"
      certool --genkey --privkey="${priv_key_path}" --pubkey="${pub_key_path}" \
        --srp-upn administrator@${lightwave_domain} --srp-pwd ${lightwave_password} --server ${lightwave_address}
    fi

    # Generate certificate if it doesn't exist
    if [ ! -f "${host_crt_path}" ]; then
      echo "Creating cert for ${host_address}"
      certool --gencert --privkey="${priv_key_path}" --cert="${host_crt_path}" \
        --srp-upn administrator@${lightwave_domain} --srp-pwd ${lightwave_password} \
        --server ${lightwave_address} --config "${config_file_path}"

      cat ${host_crt_path} ${priv_key_path} > ${host_pem_path}

      # Generate pkcs12 keystore
      openssl pkcs12 -export -in ${host_crt_path} -inkey ${priv_key_path} -out hostkeystore.p12 -name MACHINE_CERT_${host_address} \
        -password pass:${lightwave_password}

      # Convert it into JKS
      keytool -importkeystore -deststorepass ${lightwave_password} -destkeypass ${lightwave_password} \
        -destkeystore /keystore.jks -srckeystore hostkeystore.p12 -srcstoretype PKCS12 -srcstorepass ${lightwave_password} \
        -alias MACHINE_CERT_${host_address}

    fi

    # listing /etc/vmware/ssl contents before copying
    echo "listing /etc/vmware/ssl contents before copying"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} ls /etc/vmware/ssl

    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${host_crt_path} ${username}@${host_address}:/etc/vmware/ssl
    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${host_pem_path} ${username}@${host_address}:/etc/vmware/ssl
    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${priv_key_path} ${username}@${host_address}:/etc/vmware/ssl

    # listing /etc/vmware/ssl contents after copying
    echo "listing /etc/vmware/ssl contents after coying"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} ls /etc/vmware/ssl

    rm -rf "${cert_dir}"
  fi
}

if [ "$create_cert" == "true" ]
then
  create_and_copy_certificate
else
  # this is the cert generated by default through

  if [ ! -d "$cert_dir" ]; then
    mkdir -p ${cert_dir}

    echo "Creating cert for ${host_address}"
    openssl req -subj '/CN=photon-controller.com/O=VMware Inc./C=US' -new -newkey rsa:1024 -days 1095 -nodes -x509 -keyout ${priv_key_path} -out ${host_crt_path}
    cat ${host_crt_path} ${priv_key_path} > ${host_pem_path}

    # Generate pkcs12 keystore
    openssl pkcs12 -export -in ${host_crt_path} -inkey ${priv_key_path} -out hostkeystore.p12 -name MACHINE_CERT_${host_address} -password pass:${lightwave_password}

    # no need to import into keystore since in the non-auth case we accept any cert

    # listing /etc/vmware/ssl contents before copying
    echo "listing /etc/vmware/ssl contents before copying"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} ls /etc/vmware/ssl

    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${host_crt_path} ${username}@${host_address}:/etc/vmware/ssl
    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${host_pem_path} ${username}@${host_address}:/etc/vmware/ssl
    sshpass -p "$password" scp -o StrictHostKeyChecking=no ${priv_key_path} ${username}@${host_address}:/etc/vmware/ssl

    # listing /etc/vmware/ssl contents after copying
    echo "listing /etc/vmware/ssl contents after coying"
    sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} ls /etc/vmware/ssl

    # removing all keys afterwars due to auth case needing to push proper lightwave generated key/cert files
    rm -rf ${cert_dir}
  fi
fi

sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} date
sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} esxcli software vib list

install_vib

sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} esxcli software vib list
sshpass -p "$password"  ssh -o StrictHostKeyChecking=no ${username}@${host_address} date
